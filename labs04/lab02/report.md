# Отчет по лабораторной работе 2
# Наследование и Абстракция

**Дата:** 05-12-2025
**Семестр:** 2 курс, 1 семестр
**Группа:** ПИН-Б-О-24-2
**Дисциплина:** Технологии программирования
**Студент:** Осипов Александр Сергеевич

## Цель работы

Расширить систему учета сотрудников, создав иерархию классов на основе наследования. Ввести абстрактные классы для определения общего интерфейса. Реализовать различные типы сотрудников (Manager, Developer, Salesperson) с переопределением методов расчета зарплаты.

## Теоретическая часть

**Наследование** - это механизм ООП, позволяющий создавать новый класс на основе существующего, наследуя его атрибуты и методы. Это обеспечивает повторное использование кода и построение иерархий классов.

**Абстракция** - это принцип ООП, позволяющий определять общий интерфейс для группы связанных классов через абстрактные классы и методы. В Python абстракция реализуется через модуль `abc` (Abstract Base Classes).

**Паттерн Factory Method** - это порождающий паттерн проектирования, который предоставляет интерфейс для создания объектов, позволяя подклассам решать, какой класс инстанцировать.

## Практическая часть

### Выполненные задачи

- Задача 1: Создан абстрактный базовый класс `AbstractEmployee` с абстрактными методами `calculate_salary()` и `get_info()`
- Задача 2: Класс `Employee` переделан для наследования от `AbstractEmployee` с реализацией абстрактных методов
- Задача 3: Создан класс `Manager` с дополнительным атрибутом `bonus` и переопределением метода расчета зарплаты
- Задача 4: Создан класс `Developer` с атрибутами `tech_stack` и `seniority_level`, методом `add_skill()`
- Задача 5: Создан класс `Salesperson` с атрибутами `commission_rate` и `sales_volume`, методом `update_sales()`
- Задача 6: Реализован класс `EmployeeFactory` с фабричным методом для создания объектов различных типов
- Задача 7: Создана демонстрационная программа с примерами работы всех классов

### Ключевые фрагменты кода

#### Абстрактный базовый класс

```python
from abc import ABC, abstractmethod

class AbstractEmployee(ABC):
    @abstractmethod
    def calculate_salary(self) -> float:
        """Абстрактный метод для расчета зарплаты."""
        pass
    
    @abstractmethod
    def get_info(self) -> str:
        """Абстрактный метод для получения информации."""
        pass
```

#### Наследование и переопределение методов

```python
class Manager(Employee):
    def __init__(self, employee_id: int, name: str, department: str, 
                 base_salary: float, bonus: float):
        super().__init__(employee_id, name, department, base_salary)
        self.bonus = bonus
    
    def calculate_salary(self) -> float:
        """Переопределение метода расчета зарплаты."""
        return self.base_salary + self.__bonus
```

#### Фабричный метод

```python
class EmployeeFactory:
    @staticmethod
    def create_employee(emp_type: str, **kwargs) -> AbstractEmployee:
        if emp_type.lower() == "manager":
            return Manager(**kwargs)
        # ... другие типы
```

## Результаты выполнения

### Пример работы программы

```bash
================================================================================
Демонстрация работы системы учета сотрудников
Часть 2: Наследование и Абстракция
================================================================================

1. Создание экземпляров каждого типа сотрудника:
--------------------------------------------------------------------------------
Создан обычный сотрудник: Иван Петров
Создан менеджер: Мария Сидорова
Создан разработчик: Алексей Иванов
Создан продавец: Елена Козлова

2. Информация о каждом сотруднике:
--------------------------------------------------------------------------------

Сотрудник [id: 1, имя: Иван Петров, отдел: Администрация, базовая зарплата: 40000.0], итоговая зарплата: 40000.0
  → Рассчитанная зарплата: 40000.0

Сотрудник [id: 2, имя: Мария Сидорова, отдел: Менеджмент, базовая зарплата: 70000.0], бонус: 2000.0, итоговая зарплата: 72000.0
  → Рассчитанная зарплата: 72000.0

Сотрудник [id: 3, имя: Алексей Иванов, отдел: Разработка, базовая зарплата: 50000.0], уровень: senior, технологии: [Python, SQL, Docker], итоговая зарплата: 100000.0
  → Рассчитанная зарплата: 100000.0

Сотрудник [id: 4, имя: Елена Козлова, отдел: Продажи, базовая зарплата: 35000.0], процент комиссии: 15.0%, объем продаж: 100000.0, итоговая зарплата: 50000.0
  → Рассчитанная зарплата: 50000.0

5. Полиморфное поведение - работа с коллекцией объектов:
--------------------------------------------------------------------------------

Всего сотрудников: 8
Общая сумма зарплат всех сотрудников: 516000.00

6. Статистика по типам сотрудников:
--------------------------------------------------------------------------------
Employee: 2 чел., средняя зарплата: 35000.00
Manager: 2 чел., средняя зарплата: 81500.00
Developer: 2 чел., средняя зарплата: 83750.00
Salesperson: 2 чел., средняя зарплата: 57750.00
```

### Тестирование

- Модульные тесты пройдены - все классы корректно создаются и работают
- Интеграционные тесты пройдены - наследование и полиморфизм работают корректно
- Производительность соответствует требованиям - фабричный метод работает эффективно

### UML-диаграмма классов

UML-диаграмма создана в формате PlantUML и находится в файле `report/uml_diagram.puml`.

Диаграмма показывает:
- Абстрактный класс `AbstractEmployee` с абстрактными методами
- Иерархию наследования: `Employee` наследуется от `AbstractEmployee`
- Специализированные классы: `Manager`, `Developer`, `Salesperson` наследуются от `Employee`
- Класс `EmployeeFactory` для создания объектов

## Выводы

1. **Абстракция успешно реализована** - создан абстрактный базовый класс `AbstractEmployee`, который определяет общий интерфейс для всех типов сотрудников через абстрактные методы.

2. **Наследование применено корректно** - все специализированные классы (`Manager`, `Developer`, `Salesperson`) наследуются от базового класса `Employee`, переиспользуя общий код и переопределяя методы расчета зарплаты.

3. **Полиморфизм демонстрируется** - работа с коллекцией объектов разных типов через общий интерфейс `AbstractEmployee` показывает полиморфное поведение.

4. **Паттерн Factory Method реализован** - класс `EmployeeFactory` позволяет создавать объекты различных типов сотрудников единообразным способом, что упрощает управление созданием объектов.

5. **Код готов к расширению** - архитектура позволяет легко добавлять новые типы сотрудников, наследуясь от `Employee` или `AbstractEmployee`.

## Ответы на контрольные вопросы

1. **Что такое наследование в ООП?** - Наследование - это механизм ООП, позволяющий создавать новый класс на основе существующего, наследуя его атрибуты и методы, что обеспечивает повторное использование кода.

2. **Что такое абстрактный класс?** - Абстрактный класс - это класс, который не может быть инстанцирован напрямую и содержит хотя бы один абстрактный метод, который должен быть реализован в дочерних классах.

3. **В чем разница между наследованием и композицией?** - Наследование создает отношение "is-a" (является), а композиция - отношение "has-a" (имеет). Наследование используется для создания иерархий классов, композиция - для построения сложных объектов из более простых.

4. **Что такое переопределение метода?** - Переопределение метода - это замена реализации метода родительского класса в дочернем классе, позволяющая изменить поведение метода для конкретного типа объекта.

5. **Зачем нужен паттерн Factory Method?** - Factory Method позволяет инкапсулировать логику создания объектов, делая код более гибким и расширяемым, а также упрощая добавление новых типов объектов.

## Приложения

- [Исходный код: `project/`](project/)
- [UML-диаграмма: `report/uml_diagram.puml`](report/uml_diagram.puml)
- [Задание: `task.md`](task.md)

