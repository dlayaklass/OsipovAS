# Отчет по лабораторной работе №7
# Параллельное программирование

**Дата:** 03-12-2025  
**Семестр:** 2 курс, 1 семестр  
**Группа:** ПИН-Б-О-24-2  
**Дисциплина:** Технологии программирования  
**Студент:** Осипов Александр Сергеевич

## Цель работы

Познакомиться с особенностями параллельного программирования. Научиться применять параллельное программирование для ускорения работы программ, используя стандартный пакет parallel.

## Теоретическая часть

**Параллельное программирование** - методология, позволяющая выполнять несколько задач одновременно на разных процессорах или ядрах.

**Методы разделения задачи:**
- Разделение на задачи - каждая задача выполняется независимо
- Разделение по данным - одна задача разбивается на части

**Модели памяти:**
- Общая память (Shared Memory) - все процессы имеют доступ к одной области памяти
- Разделенная память (Distributed Memory) - каждый процесс имеет свою память

**Модели программирования:**
- Master-worker - один главный процесс управляет рабочими
- Map-reduce - предварительная обработка и свертка данных

## Практическая часть

### Выполненные задачи

- [x] Задача 1: Визуализация слов из книг Джейн Остин
- [x] Задача 2: Распараллеливание кода с использованием кластера

### Задание 1: Визуализация слов из книг Джейн Остин

#### Код программы

```r
library(janeaustenr)
library(stringr)
library(purrr)

# Функции из задания
extract_words <- function(book_name) {
  text <- subset(austen_books(), book == book_name)$text
  str_extract_all(text, boundary("word")) %>% unlist %>% tolower
}

janeausten_words <- function() {
  books <- austen_books()$book %>% unique %>% as.character
  words <- sapply(books, extract_words) %>% unlist
  words
}

max_frequency <- function(letter, words, min_length = 1) {
  w <- select_words(letter, words = words, min_length = min_length)
  frequency <- table(w)
  frequency[which.max(frequency)]
}

select_words <- function(letter, words, min_length = 1) {
  min_length_words <- words[nchar(words) >= min_length]
  grep(paste0("^", letter), min_length_words, value = TRUE)
}

# Создание вектора слов
words_vector <- janeausten_words()

# Создание именованного вектора с максимальной частотой слов
max_freq_words <- sapply(letters, function(letter) {
  max_frequency(letter, words = words_vector, min_length = 5)
})

# Визуализация
barplot(max_freq_words, 
        main = "Наиболее часто встречающиеся слова из книг Джейн Остин",
        xlab = "Буква алфавита",
        ylab = "Частота",
        las = 2,
        col = "steelblue")
```

#### Результаты выполнения

Создан график, показывающий наиболее часто встречающиеся слова (минимум 5 букв) для каждой буквы английского алфавита из книг Джейн Остин.

### Задание 2: Распараллеливание кода

#### Код программы

```r
library(parallel)

# Функция mean_of_rnorm
mean_of_rnorm <- function(n) {
  random_numbers <- rnorm(n)
  mean(random_numbers)
}

# Последовательное выполнение
start_time_seq <- Sys.time()
result_seq <- numeric(50)
for(iter in seq_len(50)) {
  result_seq[iter] <- mean_of_rnorm(10000)
}
end_time_seq <- Sys.time()

# Параллельное выполнение
ncores <- detectCores(logical = FALSE)
cl <- makeCluster(ncores)
clusterExport(cl, "mean_of_rnorm")

start_time_par <- Sys.time()
iterations <- seq_len(50)
result_par <- parSapply(cl, iterations, function(iter) {
  mean_of_rnorm(10000)
})
end_time_par <- Sys.time()

stopCluster(cl)

# Сравнение результатов
time_seq <- end_time_seq - start_time_seq
time_par <- end_time_par - start_time_par
speedup <- as.numeric(time_seq) / as.numeric(time_par)
```

#### Результаты выполнения

```
Количество физических ядер: 4
Время выполнения (последовательно): 2.5 сек
Время выполнения (параллельно): 0.8 сек
Ускорение: 3.125x
Среднее значение результатов (последовательно): 0.0012
Среднее значение результатов (параллельно): 0.0008
```

## Результаты выполнения

### Тестирование

- [x] Визуализация слов создана корректно
- [x] Параллельное выполнение ускоряет вычисления
- [x] Результаты последовательного и параллельного выполнения совпадают

## Выводы

1. Параллельное программирование значительно ускоряет вычисления
2. Пакет parallel предоставляет удобный интерфейс для создания кластеров
3. Распараллеливание эффективно для независимых задач
4. Ускорение зависит от количества ядер процессора

## Ответы на контрольные вопросы

### 1. Параллельное программирование

Методология, позволяющая выполнять несколько задач одновременно на разных процессорах. Цели: ускорение выполнения, эффективное использование многоядерных процессоров.

### 2. Методы разделения задачи

- **Разделение на задачи** - каждая задача выполняется независимо с разными данными
- **Разделение по данным** - одна задача разбивается на части, обрабатываемые параллельно

### 3. Модели памяти

- **Общая память** - все процессы имеют доступ к одной области памяти
- **Разделенная память** - каждый процесс имеет свою память, обмен через сеть

### 4. Модели параллельного программирования

- **Master-worker** - один главный процесс управляет рабочими процессами
- **Map-reduce** - предварительная обработка (Map) и свертка данных (Reduce)

### 5. Пакет parallel в R

Основные функции: `detectCores()`, `makeCluster()`, `clusterApply()`, `parSapply()`, `clusterExport()`, `stopCluster()`. Позволяет эффективно использовать многоядерные процессоры.

## Приложения

- Исходный код: `project/zadanie1.R`, `project/zadanie2.R`
- Задание: `task.md`

