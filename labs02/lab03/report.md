# Отчет по лабораторной работе №3
# Объектно-ориентированное программирование

**Дата:** 03-12-2025  
**Семестр:** 2 курс, 1 семестр  
**Группа:** ПИН-Б-О-24-2  
**Дисциплина:** Технологии программирования  
**Студент:** Осипов Александр Сергеевич

## Цель работы

Познакомиться с особенностями объектно-ориентированного программирования. Научиться создавать собственные классы с использованием R6. Решить задания в соответствующем стиле программирования.

## Теоретическая часть

Объектно-ориентированное программирование (ООП) - методология программирования, основанная на представлении программы в виде совокупности объектов, каждый из которых является экземпляром определенного класса, а классы образуют иерархию наследования.

**Механизмы ООП:**
- Абстракция
- Инкапсуляция
- Наследование
- Полиморфизм
- Композиция

## Практическая часть

### Выполненные задачи

- [x] Задача 1: Создание дженерика для вычисления площади фигур
- [x] Задача 2: Создание класса Микроволновая печь
- [x] Задача 3: Создание класса Копилка

### Задание 1: Дженерик для вычисления площади фигур

#### Код программы

```r
# Создание дженерика get_area
get_area <- function(x, ...) {
  UseMethod("get_area")
}

# Метод по умолчанию
get_area.default <- function(x, ...) {
  return("Невозможно обработать данные. Неизвестный тип фигуры.")
}

# Класс для треугольника
triangle_vec <- c(10, 5)
class(triangle_vec) <- "triangle"
get_area.triangle <- function(x, ...) {
  return(0.5 * x[1] * x[2])
}

# Класс для квадрата
square_vec <- c(5)
class(square_vec) <- "square"
get_area.square <- function(x, ...) {
  return(x[1] * x[1])
}

# Класс для прямоугольника
rectangle_vec <- c(8, 6)
class(rectangle_vec) <- "rectangle"
get_area.rectangle <- function(x, ...) {
  return(x[1] * x[2])
}

# Класс для круга
circle_vec <- c(4)
class(circle_vec) <- "circle"
get_area.circle <- function(x, ...) {
  return(pi * x[1] * x[1])
}
```

#### Результаты выполнения

```
Треугольник (основание=10, высота=5): Площадь = 25
Квадрат (сторона=5): Площадь = 25
Прямоугольник (длина=8, ширина=6): Площадь = 48
Круг (радиус=4): Площадь = 50.26548
Неизвестная фигура: Невозможно обработать данные. Неизвестный тип фигуры.
```

### Задание 2: Класс Микроволновая печь

#### Код программы

```r
library(R6)

MicrowaveOven <- R6Class(
  "MicrowaveOven",
  private = list(
    power = 800,
    door_open = FALSE
  ),
  public = list(
    initialize = function(power = 800, door_open = FALSE) {
      private$power <- power
      private$door_open <- door_open
    },
    open_door = function() {
      private$door_open <- TRUE
      cat("Дверца открыта.\n")
    },
    close_door = function() {
      private$door_open <- FALSE
      cat("Дверца закрыта.\n")
    },
    cook = function() {
      if (private$door_open) {
        cat("ОШИБКА: Дверца открыта!\n")
        return(invisible(NULL))
      }
      cooking_time <- 60 * (800 / private$power)
      cat("Начато приготовление... Время:", round(cooking_time, 2), "сек\n")
      Sys.sleep(cooking_time)
      cat("Пища готова!\n")
    }
  )
)
```

#### Результаты выполнения

```
=== Создание микроволновой печи №1 (значения по умолчанию) ===
Микроволновая печь создана. Мощность: 800 Вт
Дверца закрыта.
Приготовление на мощности 800 Вт: Время: 60 сек

=== Создание микроволновой печи №2 (мощность 1200 Вт) ===
Микроволновая печь создана. Мощность: 1200 Вт
Приготовление на мощности 1200 Вт: Время: 40 сек
```

### Задание 3: Класс Копилка

#### Код программы

```r
PiggyBank <- R6Class(
  "PiggyBank",
  private = list(
    balance = 0,
    capacity = 1000,
    is_broken = FALSE
  ),
  public = list(
    initialize = function(initial_balance = 0, capacity = 1000) {
      private$balance <- initial_balance
      private$capacity <- capacity
    },
    deposit = function(amount) {
      if (private$is_broken) {
        cat("ОШИБКА: Копилка разбита!\n")
        return(invisible(NULL))
      }
      if (private$balance + amount > private$capacity) {
        cat("ОШИБКА: Копилка переполнена!\n")
        return(invisible(NULL))
      }
      private$balance <- private$balance + amount
      cat("Добавлено", amount, "единиц. Баланс:", private$balance, "\n")
    },
    break_bank = function() {
      withdrawn <- private$balance
      private$balance <- 0
      private$is_broken <- TRUE
      cat("Копилка разбита! Извлечено", withdrawn, "единиц\n")
      return(withdrawn)
    }
  )
)
```

#### Результаты выполнения

```
=== Создание копилки ===
Копилка создана. Вместимость: 1000 единиц

=== Добавление денег ===
Добавлено 100 единиц. Баланс: 100
Добавлено 250 единиц. Баланс: 350
Добавлено 50 единиц. Баланс: 400

=== Разбитие копилки ===
Копилка разбита! Извлечено 400 единиц
```

## Результаты выполнения

### Тестирование

- [x] Дженерик корректно обрабатывает разные классы фигур
- [x] Класс Микроволновая печь работает с разными мощностями
- [x] Класс Копилка корректно управляет балансом и состоянием

## Выводы

1. ООП позволяет инкапсулировать данные и методы в классах
2. Дженерики обеспечивают полиморфизм в R
3. R6 предоставляет удобный способ создания классов с приватными и публичными членами
4. Инкапсуляция защищает внутреннее состояние объектов

## Ответы на контрольные вопросы

### 1. Принципы ООП по Алану Кею

- Все является объектом
- Вычисления через взаимодействие объектов
- Взаимодействие через сообщения
- Независимая память объектов
- Объекты - экземпляры классов
- Классы определяют поведение
- Иерархия наследования
- Разделение ответственности

### 2. Механизмы ООП

- **Абстракция** - определение характеристик объекта
- **Инкапсуляция** - сокрытие внутренних деталей
- **Наследование** - создание специализированных классов
- **Полиморфизм** - одна операция в разных объектах
- **Композиция** - объекты включают другие объекты

### 3. Основные понятия ООП

**Объект** - отдельный представитель класса с состоянием и поведением.  
**Класс** - способ описания сущности, определяющий состояние и поведение.  
**Атрибут класса** - характеристика класса, описывающая значения объектов.  
**Методы класса** - функции для работы с данными класса.

### 4. Создание и назначение дженериков

Дженерик - функция, способная принимать разные структуры данных и работать по-разному. Назначение: создание единого интерфейса для работы с разными типами данных.

### 5. Создание класса в R6

Используется функция `R6Class()` с параметрами: имя класса, списки `private`, `public`, `active`.

### 6. Структура класса в R6

- **private** - приватные поля и методы
- **public** - публичные методы
- **active** - активные поля (для чтения)

## Приложения

- Исходный код: `project/zadanie1.R`, `project/zadanie2.R`, `project/zadanie3.R`
- Задание: `task.md`

