# Отчёт по лабораторной работе (часть 2)
# Тестирование асинхронного кода в Go

**Дата:** 27-12-2025  
**Семестр:** 2 курс, 1 семестр  
**Группа:** ПИН-Б-О-24-2  
**Дисциплина:** Технологии программирования  
**Студент:** Осипов Александр Сергеевич

---

## Цель работы
Освоить методики тестирования конкурентного кода, горутин, каналов и асинхронных операций в Go. Научиться писать надежные тесты для параллельных программ.

## Задачи работы
1. Написать тесты для базовых горутин и каналов
2. Написать тесты для Worker Pool
3. Написать тесты для HTTP сервера
4. Проверить отсутствие гонок данных с помощью детектора гонок

---

## Теоретическая часть
### Основные понятия
- **Unit-тестирование:** Тестирование отдельных компонентов в изоляции
- **Детектор гонок:** Инструмент Go для обнаружения гонок данных в конкурентных программах
- **httptest:** Пакет для тестирования HTTP обработчиков без запуска реального сервера
- **Покрытие кода:** Метрика, показывающая процент кода, покрытого тестами

### Используемые технологии
- **testing пакет:** Стандартная библиотека Go для написания тестов
- **go test -race:** Флаг для запуска детектора гонок данных
- **go test -cover:** Флаг для измерения покрытия кода тестами
- **sync пакет:** Для синхронизации в тестах конкурентного кода

---

## Практическая часть

### 1. Подготовка окружения
```bash
cd lab02/project
go mod init lab-async-go
go test ./... -v
```

### 2. Реализованные компоненты

#### 2.1. Тесты для горутин
**Файл:** `internal/async/goroutines_test.go`
- TestCounter: проверка конкурентного доступа к Counter
- TestProcessItems: проверка параллельной обработки элементов

**Пример кода:**
```go
func TestCounter(t *testing.T) {
	counter := &Counter{}
	var wg sync.WaitGroup
	
	for i := 0; i < 100; i++ {
		wg.Add(1)
		go func() {
			defer wg.Done()
			counter.Increment()
		}()
	}
	
	wg.Wait()
	
	if counter.Value() != 100 {
		t.Errorf("Expected counter value 100, got %d", counter.Value())
	}
}
```

#### 2.2. Тесты для каналов
**Файл:** `internal/async/channels_test.go`
- TestBufferedChannelProcessor: проверка обработки данных через буферизованный канал
- TestChannelTimeout: проверка работы таймаутов в select

#### 2.3. Тесты для Worker Pool
**Файл:** `internal/async/worker_pool_test.go`
- TestWorkerPool_BasicFunctionality: проверка базовой функциональности пула
- TestWorkerPool_ConcurrentSubmission: проверка конкурентной отправки задач

#### 2.4. Тесты для HTTP сервера
**Файл:** `internal/server/http_test.go`
- TestHandler: проверка корректности работы HTTP обработчика
- TestConcurrentRequests: проверка обработки конкурентных запросов

### 3. Тестирование

#### 3.1. Unit-тесты
**Команды тестирования:**
```bash
go test ./internal/async/... -v
go test ./internal/server/... -v
go test ./... -v
```

**Результаты:**
- Все unit-тесты пройдены успешно
- Тесты для Counter проверяют корректность работы с мьютексом
- Тесты для каналов проверяют обработку данных и таймауты
- Тесты для Worker Pool проверяют распределение задач

#### 3.2. Тестирование с детектором гонок
**Метрики:**
- Детектор гонок не выявил проблем: `go test -race ./...`
- Покрытие кода: более 70%: `go test -cover ./...`
- Все тесты проходят стабильно при многократном запуске

---

## Результаты

### 1. Производительность
- Тесты выполняются быстро (менее 5 секунд для всех тестов)
- Детектор гонок не замедляет выполнение критично
- Конкурентные тесты проверяют работу под нагрузкой

### 2. Функциональность
- Все компоненты покрыты тестами
- Тесты проверяют как успешные сценарии, так и граничные случаи
- Тесты для HTTP сервера используют httptest для изоляции

### 3. Надежность
- Детектор гонок подтвердил отсутствие гонок данных
- Тесты стабильны и воспроизводимы
- Покрытие кода превышает 70%

---

## Примеры работы

### Запуск приложения:
```bash
go run cmd/main.go
```

**Вывод:**
```
=== Лабораторная работа: Тестирование асинхронного кода в Go ===

Для запуска тестов выполните:
  go test ./... -v
  go test ./... -race
  go test ./... -cover

Демонстрация компонентов:
...
```

### Тестирование:
```bash
go test ./... -v
```

**Результат:**
```
=== RUN   TestCounter
--- PASS: TestCounter (0.00s)
=== RUN   TestProcessItems
--- PASS: TestProcessItems (0.01s)
=== RUN   TestBufferedChannelProcessor
--- PASS: TestBufferedChannelProcessor (0.00s)
=== RUN   TestChannelTimeout
--- PASS: TestChannelTimeout (0.10s)
=== RUN   TestWorkerPool_BasicFunctionality
--- PASS: TestWorkerPool_BasicFunctionality (2.01s)
=== RUN   TestWorkerPool_ConcurrentSubmission
--- PASS: TestWorkerPool_ConcurrentSubmission (1.05s)
=== RUN   TestHandler
--- PASS: TestHandler (0.00s)
=== RUN   TestConcurrentRequests
--- PASS: TestConcurrentRequests (0.01s)
PASS
ok      lab-async-go/internal/async    3.175s
ok      lab-async-go/internal/server    0.015s
```

---

## Выводы

### 1. Достигнутые результаты
- Освоены методики тестирования конкурентного кода в Go
- Написаны тесты для всех компонентов асинхронного программирования
- Проверена корректность работы с детектором гонок данных

### 2. Изученные концепции
- Использование WaitGroup для синхронизации в тестах
- Тестирование каналов с таймаутами
- Использование httptest для тестирования HTTP обработчиков
- Работа с детектором гонок данных

### 3. Практическая значимость
- Умение писать тесты для конкурентного кода критично для надежности приложений
- Детектор гонок помогает находить скрытые проблемы в многопоточном коде
- Хорошее покрытие тестами упрощает рефакторинг и поддержку кода

---

## Проблемы и решения

### Проблема 1: Нестабильность тестов из-за гонок данных
**Решение:** Использование мьютексов в тестах для синхронизации доступа к общим данным. Все операции с разделяемыми ресурсами защищены мьютексами.

### Проблема 2: Таймауты в тестах каналов
**Решение:** Использование select с time.After для контроля времени выполнения тестов. Это позволяет избежать бесконечного ожидания при тестировании каналов.

---

## Рекомендации для будущих работ
1. Изучить бенчмарки (benchmark tests) для измерения производительности
2. Освоить интеграционное тестирование для проверки взаимодействия компонентов
3. Изучить инструменты для анализа покрытия кода и профилирования тестов

---

## Приложения

### Приложение A: Структура проекта
```
lab-async-go/
├── cmd/
│   └── main.go
├── internal/
│   ├── async/
│   │   ├── goroutines.go
│   │   ├── goroutines_test.go
│   │   ├── channels.go
│   │   ├── channels_test.go
│   │   ├── worker_pool.go
│   │   └── worker_pool_test.go
│   └── server/
│       ├── http.go
│       └── http_test.go
├── go.mod
└── README.md
```

### Приложение B: Команды для запуска
```bash
# Запуск всех тестов
go test ./...

# Запуск тестов с детектором гонок
go test -race ./...

# Покрытие кода
go test -cover ./...

# Детальное покрытие
go test -coverprofile=coverage.out ./...
go tool cover -html=coverage.out
```

### Приложение C: Исходный код
Исходный код находится в директории `project/`
