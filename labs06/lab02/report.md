# Отчет по лабораторной работе 2
# Python и функциональные возможности

**Дата:** 15-12-2025  
**Семестр:** 2 курс, 1 семестр  
**Группа:** ПИН-Б-О-24-2  
**Дисциплина:** Технологии программирования
**Студент:** Осипов Александр Сергеевич

## Цель работы
Изучить возможности функционального программирования в Python, освоить работу с функциями как объектами первого класса, изучить встроенные функции высшего порядка и научиться применять функциональные подходы в императивном языке.

## Теоретическая часть
Python поддерживает функциональную парадигму, хотя не является чисто функциональным языком. Основные концепции:
- Функции как объекты первого класса - можно присваивать переменным, передавать как аргументы
- Lambda-функции - анонимные функции в одной строке
- Замыкания - функции, запоминающие окружение создания
- Декораторы - функции, модифицирующие поведение других функций
- Генераторы - функции, возвращающие итератор

## Практическая часть

### Выполненные задачи
- [x] Задача 1: Изучены функции как объекты первого класса в Python
- [x] Задача 2: Освоены встроенные функции высшего порядка: map, filter, reduce
- [x] Задача 3: Научился использовать lambda-функции и замыкания
- [x] Задача 4: Изучены генераторы и списковые включения
- [x] Задача 5: Освоено создание и использование декораторов
- [x] Задача 6: Выполнены практические задания

### Ключевые фрагменты кода

Функции как объекты:
```python
def apply_function(func, value):
    return func(value)

result = apply_function(square, 5)
```

Lambda и замыкания:
```python
def create_counter():
    count = 0
    def counter():
        nonlocal count
        count += 1
        return count
    return counter
```

Функции высшего порядка:
```python
student_names = list(map(lambda student: student['name'], students))
top_students = list(filter(lambda student: student['grade'] >= 90, students))
product = reduce(lambda x, y: x * y, numbers)
```

Декоратор:
```python
def timer(func):
    @wraps(func)
    def wrapper(*args, **kwargs):
        start_time = time.time()
        result = func(*args, **kwargs)
        print(f"Время: {time.time() - start_time:.4f} сек")
        return result
    return wrapper
```

## Результаты выполнения

### Пример работы программы
```bash
=== Демонстрация функционального программирования в Python ===

1. Функции как объекты:
apply_function(square, 5) = 25

2. Lambda и замыкания:
Счетчик: 1, 2, 3

3. Функции высшего порядка:
Произведение чисел: 3628800

4. Генераторы и включения:
Четные квадраты: [4, 16, 36, 64, 100]

5. Декораторы:
Привет, Мария!
Привет, Мария!
Привет, Мария!
```

### Тестирование
- [x] Модульные тесты пройдены
- [x] Интеграционные тесты пройдены
- [x] Производительность соответствует требованиям

## Выводы
1. Python поддерживает основные концепции ФП, хотя и не является чисто функциональным языком
2. Функции высшего порядка делают код более декларативным и читаемым
3. Генераторы эффективны для работы с большими объемами данных
4. Декораторы позволяют добавлять функциональность без изменения исходного кода
5. Lambda-функции удобны для коротких операций, но могут ухудшать читаемость при усложнении

## Ответы на контрольные вопросы
1. **Что такое функции первого класса и как Python их поддерживает?** - Функции первого класса могут быть присвоены переменным, переданы как аргументы и возвращены из других функций. Python полностью поддерживает это.

2. **В чем разница между lambda-функциями и обычными функциями?** - Lambda-функции анонимны, ограничены одним выражением, не могут содержать операторы. Обычные функции могут содержать множественные операторы и имеют имя.

3. **Как работают замыкания и для чего они используются?** - Замыкания запоминают переменные из внешней области видимости. Используются для создания функций с состоянием, фабрик функций.

4. **Что такое декораторы и как создавать декораторы с параметрами?** - Декораторы - функции, модифицирующие другие функции. Декораторы с параметрами требуют тройной вложенности: внешняя функция принимает параметры, средняя - декорируемую функцию, внутренняя - обертку.

5. **Какие преимущества дают генераторы по сравнению со списками?** - Генераторы ленивы, экономят память, вычисляют значения по требованию. Списки создаются полностью в памяти сразу.

## Приложения
- Исходный код находится в папке `project/`
- Все модули реализованы и протестированы

